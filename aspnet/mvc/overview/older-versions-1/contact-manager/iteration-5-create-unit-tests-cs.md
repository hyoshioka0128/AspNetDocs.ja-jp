---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: '繰り返し #5 – 単体テストを作成 (c#) |Microsoft Docs'
author: microsoft
description: 5 番目のイテレーションでアプリケーションと簡単に維持単体テストを追加して変更します。 データ モデル クラスをモックして o の単体テストをビルドしています.
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 68080859e205283f56d8f543bfa06b76bb22a39d
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59408863"
---
# <a name="iteration-5--create-unit-tests-c"></a>繰り返し #5 – 単体テストの作成 (c#)

によって[Microsoft](https://github.com/microsoft)

[コードをダウンロードします。](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> 5 番目のイテレーションでアプリケーションと簡単に維持単体テストを追加して変更します。 データ モデル クラスの模擬テストを実行し、コント ローラーと検証ロジックの単体テストをビルドします。


## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>連絡先管理 ASP.NET MVC アプリケーション (c#) の構築

このチュートリアル シリーズでは、開始から終了に全体連絡先管理アプリケーションを構築します。 Contact Manager アプリケーションは、ユーザーの一覧については店舗連絡先情報の名前、電話番号、電子メール アドレスにするようにことができます。

複数のイテレーションにおける、アプリケーションを構築します。 反復処理ごとに、アプリケーション徐々 に向上します。 この複数のイテレーションのアプローチの目的は、各変更の理由を理解するためです。

- 繰り返し #1 - は、アプリケーションを作成します。 最初のイテレーションを作成、連絡先マネージャー最も簡単な方法で考えられるします。 基本的なデータベース操作のサポートを追加します。作成、読み取り、更新、および削除 (CRUD)。

- 繰り返し #2 - は、素敵に見えるアプリケーションを作成します。 このイテレーションで、アプリケーションの見た目を向上させる、既定の ASP.NET MVC ビュー マスター ページを変更し、カスケード スタイル シート。

- 繰り返し #3 - フォーム検証を追加します。 3 番目のイテレーションでは、基本的なフォーム検証を追加します。 ユーザーは、必要なフォームのフィールドを完了しなくても、フォームを送信できないようにようにします。 また、電子メール アドレスと電話番号を検証しました。

- 繰り返し #4 - は、アプリケーションを疎結合を作成します。 この 4 番目のイテレーションで、保守し、Contact Manager アプリケーションの変更を容易にできるようにするソフトウェア設計パターンをいくつかの利点を実行します。 たとえば、Repository パターンと依存関係の注入パターンを使用するようにアプリケーションをリファクタリングします。

- 繰り返し #5 - 単体テストを作成します。 5 番目のイテレーションでアプリケーションと簡単に維持単体テストを追加して変更します。 データ モデル クラスの模擬テストを実行し、コント ローラーと検証ロジックの単体テストをビルドします。

- 繰り返し #6 - は、テスト駆動開発を使用します。 この 6 番目のイテレーションでは、アプリケーションに新しい機能を追加には、まず単体テストの記述、単体テストに対してコードを記述します。 このイテレーションは、連絡先グループを追加します。

- 繰り返し #7 - Ajax 機能を追加します。 7 番目のイテレーションで改良、応答性と、アプリケーションのパフォーマンスの Ajax のサポートを追加します。


## <a name="this-iteration"></a>このイテレーション

Contact Manager アプリケーションの前のイテレーションより緩やかに結合され、アプリケーションをリファクタリングします。 ここには、個別のコント ローラー、サービス、およびリポジトリ層にアプリケーションが区切られます。 各レイヤーは、インターフェイスを介してその下にある層と対話します。

アプリケーションを維持し、変更が発生しやすいようにアプリケーションをリファクタリングします。 たとえば、新しいデータ アクセス テクノロジを使用する必要がある場合、は、リポジトリ層をコント ローラーまたはサービス層に触れることがなくに変更できますだけですいます。 疎結合、連絡先マネージャーで加えましたアプリケーションを変更する回復性が向上します。

しかし、Contact Manager アプリケーションに新しい機能を追加するときに起こるでしょうか。 または、バグの修正とどうなりますか。 コードの記述、悲しいことですが、実証済みの真実では、コードを作成する新しいバグを導入するリスクをタッチするたびにことです。

たとえば、問題のある日、上司かもしれません Contact Manager の新機能を追加することです。 彼女には、連絡先グループのサポートを追加することが希望しています。 彼女には、友人や Business などのグループに連絡先を整理するユーザーを有効にすることが希望しています。

この新しい機能を実装するのには、Contact Manager アプリケーションのすべての 3 つの層を変更する必要があります。 コント ローラー、サービス層、およびリポジトリに新しい機能を追加する必要があります。 コードの変更を開始するとすぐに、前に動作していた機能を損なう可能性があります。

前のイテレーションで行ったように、別のレイヤーにアプリケーションをリファクタリングとが良いことです。 アプリケーションの残りの部分に触れることがなくレイヤー全体に変更を加えることができるため、良いことでした。 ただし、レイヤー内のコードを簡単に管理および変更する場合は、コードの単体テストを作成する必要があります。

使用する、単体テスト コードの個々 の単位。 これらのコード単位では、全体のアプリケーション層よりも小さくなります。 通常、単体テストを使用して、コード内の特定のメソッドが期待どおりに動作するかどうかを確認します。 たとえば、ContactManagerService クラスによって公開される CreateContact() メソッドの単体テストを作成します。

アプリケーションの作業だけでの単体テストでは、セーフティ ネットをなど。 アプリケーションのコードを変更するたびに、一連の変更が既存の機能を中断するかどうかを確認する単体テストを実行できます。 単体テストは、変更を安全なコードを作成します。 単体テストのコードはすべて、アプリケーションで回復力を高めるを変更します。

このイテレーションでは、Contact Manager アプリケーションに、単体テストを追加します。 これにより、次のイテレーションで追加できます連絡先グループ、アプリケーションに既存の機能を損なうについて悩むことがなく。

> [!NOTE] 
> 
> さまざまな単体テスト フレームワークの NUnit、xUnit.net、MbUnit などがあります。 このチュートリアルでは、単体テスト フレームワークに含まれている Visual Studio を使用します。 ただし、同じくらい簡単に使用できますような別のフレームワークの 1 つ。


## <a name="what-gets-tested"></a>どのようなテストを取得します

理想の世界では、すべてのコードは単体テストでカバーなります。 理想の世界では、完璧なセーフティ ネットがあります。 任意のアプリケーションのコード行を変更して、すぐに把握、単体テストを実行することによって、変更が既存の機能を中断するかどうかをすることができます。

ただし、理想の世界でライブ t がありません。 実際には、単体テストを記述する場合、ビジネス ロジック (たとえば、検証ロジック) のテストの記述に集中することにします。 具体的には、する*しない*データ用の単体テストを記述するロジックや、ビュー ロジックにアクセスします。

便利ですが、単体テストは非常に高速実行する必要があります。 アプリケーションの単体テストの数百台 (または何千も) を蓄積することが簡単にします。 単体テストを実行する時間がかかる場合は、それらの実行を回避します。 つまり、実行時間の長い単体テストは、日常のコーディング目的で役に立たなくです。

このため、通常書きデータベースとやり取りするコードの単体テスト。 ライブ データベースに対して何百もの単体テストを実行しているは遅すぎるでしょう。 代わりに、データベースの模擬テストを実行し、モック (取り上げます以下のデータベースのモック) データベースと対話するコードを記述します。

同様の理由を通常書き込みませんビュー用の単体テスト。 ビューをテストするには、web サーバーを起動する必要があります。 Web サーバーをスピンアップは比較的低速なプロセスなので、ビューの単体テストの作成は推奨されません。

ビューには、複雑なロジックが含まれている場合、ロジックをヘルパー メソッドに移動を検討してください。 Web サーバーをスピンアップせずに実行するヘルパー メソッドの単体テストを記述することができます。

> [!NOTE] 
> 
> 書き込みは、データ アクセス ロジックのテストや、ビュー ロジックをお勧め単体テストを記述する場合、中には、関数型構築または統合テスト時にこれらのテストが非常に役に立つできます。


> [!NOTE] 
> 
> ASP.NET MVC は、Web フォーム ビュー エンジンです。 Web フォームのビュー エンジンは、web サーバーに依存するその他のビュー エンジンはできない可能性があります。


## <a name="using-a-mock-object-framework"></a>モック オブジェクト フレームワークを使用します。

単体テストを作成するときにほとんどの場合、オブジェクトのモック作成フレームワークを活用する必要があります。 オブジェクトのモック作成フレームワークでは、アプリケーションでモックとスタブ クラスを作成することができます。

たとえば、リポジトリ クラスのモック版を生成するのにオブジェクトのモック作成フレームワークを使用できます。 これにより、単体テストで、実際のリポジトリ クラスではなくもモック リポジトリ クラスを使用できます。 モック リポジトリを使用するには、単体テストを実行するときにデータベース コードの実行を回避することができます。

Visual Studio では、モック オブジェクト フレームワークは含まれません。 ただしがいくつか市販およびオープン ソースのオブジェクトのモック作成フレームワーク、.NET framework を使用できます。

1. Moq - このフレームワークは、オープン ソースの BSD license で入手できます。 Moq からダウンロードできます[ https://code.google.com/p/moq/](https://code.google.com/p/moq/)します。
2. Rhino Mocks - この framework はオープン ソースの BSD license で入手できます。 Rhino Mocks をダウンロードする[ http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)します。
3. Typemock Isolator - これは、商用フレームワークです。 試用版をダウンロードする[ http://www.typemock.com/](http://www.typemock.com/)します。

このチュートリアルで Moq を使用することにしました。 ただし、Rhino Mocks を使用する同じくらい簡単にしたり、Contact Manager アプリケーションのオブジェクトのモックを作成する Typemock Isolator です。

Moq を使用するには、次の手順を完了する必要があります。

1. .
2. ダウンロードを解凍する前に、ファイルを右クリックし、ボタンをクリックしてくださいください**ブロック解除**(図 1 参照)。
3. ダウンロードを解凍します。
4. ContactManager.Tests プロジェクトの [参照] フォルダーを右クリックして、Moq アセンブリへの参照を追加**参照の追加**します。 [参照] タブの下には、Moq を解凍したフォルダーを参照して Moq.dll アセンブリを選択します。 をクリックして、 **OK**ボタンをクリックします。
5. 次の手順を完了すると、図 2 よう、[参照] フォルダーになります。


[![Moq のブロック解除](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)

**図 01**:ブロック解除 Moq ([フルサイズの画像を表示する をクリックします](iteration-5-create-unit-tests-cs/_static/image2.png))。


[![Moq を追加した後の参照](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)

**図 02**:Moq を追加した後の参照 ([フルサイズの画像を表示する をクリックします](iteration-5-create-unit-tests-cs/_static/image4.png))。


## <a name="creating-unit-tests-for-the-service-layer"></a>サービス層の単体テストの作成

S、Contact Manager アプリケーションのサービス層の単体テストのセットを作成して開始できるようにします。 これらのテスト、検証ロジックの検証に使用します。

ContactManager.Tests プロジェクトでモデルをという名前の新しいフォルダーを作成します。 次に、Models フォルダーを右クリックし **追加、新しいテスト**します。 **新しいテストの追加**図 3 に示すダイアログが表示されます。 選択、**単体テスト**テンプレートし、新しいテスト ContactManagerServiceTest.cs 名前を付けます。 をクリックして、 **OK**テスト プロジェクトに新しいテストを追加するボタン。

> [!NOTE] 
> 
> 一般に、ASP.NET MVC プロジェクトのフォルダー構造と一致するテスト プロジェクトのフォルダー構造が必要です。 たとえば、コント ローラーのフォルダー、モデルのテストで、Models フォルダーにコント ローラーのテストを配置しなど。


[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)

**図 03**:Models\ContactManagerServiceTest.cs ([フルサイズの画像を表示する をクリックします](iteration-5-create-unit-tests-cs/_static/image6.png))。


最初に、ContactManagerService クラスによって公開される CreateContact() メソッドをテストします。 次の 5 つのテストを作成します。

- CreateContact() - その CreateContact() のテストは、有効な連絡先がメソッドに渡されるときに値 true を返します。
- CreateContactRequiredFirstName() - エラー メッセージがモデル状態のときに不足している姓の連絡先に追加されているテストは CreateContact() メソッドに渡されます。
- CreateContactRequiredLastName() - エラー メッセージがモデル状態のときに不足している姓の連絡先に追加されているテストは CreateContact() メソッドに渡されます。
- CreateContactInvalidPhone() - エラー メッセージがモデル状態のときに無効な電話番号へのアクセスに追加されているテストは CreateContact() メソッドに渡されます。
- CreateContactInvalidEmail() - エラー メッセージがモデル状態のときに無効な電子メール アドレスを持つ連絡先に追加されているテストは CreateContact() メソッドに渡される.

最初のテストは、有効な連絡先で検証エラーが発生しないことを確認します。 残りのテストは、それぞれの検証ルールを確認します。

リスト 1 で、これらのテストのコードが含まれています。

**1 - Models\ContactManagerServiceTest.cs を一覧表示します。**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]


リスト 1 で、Contact クラスを使用しているため、テスト プロジェクトに Microsoft Entity Framework への参照を追加する必要があります。 System.Data.Entity アセンブリへの参照を追加します。


1 を一覧表示するには、[TestInitialize] 属性で装飾された Initialize() という名前のメソッドが含まれています。 各単体テストの実行前に、このメソッドが自動的に呼び出される (回呼び出された 5 各単体テストの直前)。 Initialize() メソッドは、次のコード行で、モック リポジトリを作成します。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

次のコードでは、Moq フレームワークを使用して、IContactManagerRepository インターフェイスからモック リポジトリを生成します。 実際の EntityContactManagerRepository ではなく、モック リポジトリを使用して、各単体テストを実行すると、データベースへのアクセスを回避します。 モック リポジトリには、IContactManagerRepository インターフェイスのメソッドが実装されていますが、メソッドの don t が実際に何も実行します。

> [!NOTE] 
> 
> Moq フレームワークを使用する場合は、区別\_mockRepository と\_mockRepository.Object します。 以前のモックを指す&lt;IContactManagerRepository&gt;モック リポジトリの動作を指定するためのメソッドを含むクラスです。 後者の IContactManagerRepository インターフェイスを実装する実際のモック リポジトリを参照します。


ContactManagerService クラスのインスタンスを作成するときに、モック リポジトリは Initialize() メソッドで使用されます。 すべての個々 の単体テストは、ContactManagerService クラスのこのインスタンスを使用します。

1 を一覧表示するには、単体テストのそれぞれに対応する 5 つのメソッドが含まれています。 これらの各メソッドは、[TestMethod] 属性で修飾されます。 単体テストを実行すると、この属性を持つ任意のメソッドが呼び出されます。 つまり、[TestMethod] 属性で装飾した任意のメソッドは、単体テストです。

呼び出す CreateContact() が返されます値 true、Contact クラスの有効なインスタンスがメソッドに渡される CreateContact()、という名前の最初の単体テストを確認します。 テストは、連絡先クラスのインスタンスを作成するには、CreateContact() メソッドを呼び出しおよび CreateContact() が値 true を返すことを確認します。

残りのテストことを確認、無効な連絡先と CreateContact() メソッドが呼び出されたときに、false が返されます、予想される検証エラー メッセージは、モデルの状態に追加されます。 たとえば、CreateContactRequiredFirstName() テストでは、FirstName プロパティに空の文字列で連絡先クラスのインスタンスを作成します。 次に、無効な連絡先と CreateContact() メソッドが呼び出されます。 CreateContact() false を返すことと、モデルの状態が含まれている、予期される検証エラー メッセージには「名が必要です」最後に、テストを確認します

リスト 1 で単体テストを実行するには、メニュー オプションを選択して**ソリューション (CTRL + R、A) ですべてのテストを実行します。 テスト**します。 テスト結果 ウィンドウで、テストの結果が表示されます (図 4 参照)。


[![テスト結果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)

**図 04**:テスト結果 ([フルサイズの画像を表示する をクリックします](iteration-5-create-unit-tests-cs/_static/image8.png))。


## <a name="creating-unit-tests-for-controllers"></a>コント ローラーの単体テストの作成

ASP.NETMVC アプリケーションでは、ユーザーの操作のフローを制御します。 コント ローラーが適切なアクションの結果とビューのデータを返すかどうかをテストするコント ローラーをテストする場合。 コント ローラーが期待どおりの方法でモデル クラスとやり取りするかどうかをテストすることも可能性があります。

たとえば、リスト 2 には、連絡先のコント ローラー Create() メソッドの 2 つの単体テストが含まれています。 Create() メソッドは、インデックス アクションにリダイレクトし、有効な連絡先が Create() メソッドに渡されるときに、最初の単体テストを確認します。 つまり、渡されると、有効な連絡先、Create() メソッドは、インデックス アクションを表す RedirectToRouteResult を返す必要があります。

コント ローラーのレイヤーをテストする場合に、ContactManager サービス レイヤーをテストすることはありません。 そのため、Initialize メソッドに次のコードで、サービス層をモックします。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

CreateValidContact() の単体テストでは、サービス層の次のコード行を持つ CreateContact() メソッドの呼び出しの動作をモックします。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

次のコードは原因をその CreateContact() メソッドが呼び出されたときに値 true を返すモック ContactManager サービスです。 サービス層のモックを作成して、サービス層ですべてのコードを実行することがなく、コント ローラーの動作をテストできます。

2 番目の単体テストでは、無効なメンバーがメソッドに渡される Create() アクションがビューを作成するを返すことを確認します。 サービス層を次のコード行で値 false を返す CreateContact() メソッドが発生しました。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

場合は、サービス層には値 false が返されるときに、メソッドの動作は予想し Create() はビューを作成するを返す必要があります。 そうすること、コント ローラーを表示検証エラー メッセージでビューを作成し、ユーザーがその無効な連絡先のプロパティを訂正する機会。


コント ローラーの単体テストをビルドする予定の場合は、コント ローラーのアクションからの明示的なビューの名前を返す必要があります。 たとえば、次のようにビューを返さない。

return View();

代わりに、このようなビューを返します。

return View("Create");

ビューを返すときに、明示的なことがない場合、ViewResult.ViewName プロパティは空の文字列を返します。


**Listing 2 - Controllers\ContactControllerTest.cs**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a>まとめ

このイテレーションでは、Contact Manager アプリケーションの単体テストを作成しました。 予定の方法で、アプリケーションがまだ動作することを確認するには、いつでもこれらの単体テストを実行できます。 単体テストは、今後、アプリケーションを安全に変更することを有効にする、アプリケーションの安全策として機能します。

単体テストの 2 つのセットを作成しました。 最初に、このサービス層の単体テストを作成して、検証ロジックをテストしました。 次に、コント ローラー、レイヤーの単体テストを作成して、フロー制御ロジックをテストしました。 サービス レイヤーをテストするときに別に分離されたテストでは、サービス層のリポジトリ層から、リポジトリ層のモックを作成します。 コント ローラーのレイヤーをテストするときに別に分離されたテストでは、コント ローラー、レイヤーのサービス層のモックを作成します。

次のイテレーションで連絡先グループをサポートするように、Contact Manager アプリケーションを変更します。 この新しい機能は、テスト駆動開発と呼ばれるソフトウェアの設計プロセスを使用して、アプリケーションに追加します。

> [!div class="step-by-step"]
> [前へ](iteration-4-make-the-application-loosely-coupled-cs.md)
> [次へ](iteration-6-use-test-driven-development-cs.md)
