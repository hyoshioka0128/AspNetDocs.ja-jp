---
title: ASP.NET Core でのキーの管理
author: rick-anderson
description: ASP.NET Core データ保護キー管理 Api の実装の詳細について説明します。
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/key-management
ms.openlocfilehash: 431bdf2d3076c83279b78f327ddb647f69e6e584
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/01/2019
ms.locfileid: "57042579"
---
# <a name="key-management-in-aspnet-core"></a><span data-ttu-id="bad0e-103">ASP.NET Core でのキーの管理</span><span class="sxs-lookup"><span data-stu-id="bad0e-103">Key management in ASP.NET Core</span></span>

<a name="data-protection-implementation-key-management"></a>

<span data-ttu-id="bad0e-104">データ保護システムは、自動的に保護し、ペイロードの保護を解除するために使用するマスター _ キーの有効期間を管理します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-104">The data protection system automatically manages the lifetime of master keys used to protect and unprotect payloads.</span></span> <span data-ttu-id="bad0e-105">各キーは、4 つの段階のいずれかで存在できます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-105">Each key can exist in one of four stages:</span></span>

* <span data-ttu-id="bad0e-106">作成したキーをキー リング内に存在するが認証されていません。</span><span class="sxs-lookup"><span data-stu-id="bad0e-106">Created - the key exists in the key ring but has not yet been activated.</span></span> <span data-ttu-id="bad0e-107">キーの使用できません新しい保護操作十分な時間が経過するまで、キーがこのキー リングを使用しているすべてのマシンに反映されるまでの可能性を持っています。</span><span class="sxs-lookup"><span data-stu-id="bad0e-107">The key shouldn't be used for new Protect operations until sufficient time has elapsed that the key has had a chance to propagate to all machines that are consuming this key ring.</span></span>

* <span data-ttu-id="bad0e-108">アクティブな - キーはキー リング内に存在して、すべての新しい保護操作のために使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-108">Active - the key exists in the key ring and should be used for all new Protect operations.</span></span>

* <span data-ttu-id="bad0e-109">キーは、有効期限切れ - 自然な有効期間にわたって実行し、保護操作では使用できなくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-109">Expired - the key has run its natural lifetime and should no longer be used for new Protect operations.</span></span>

* <span data-ttu-id="bad0e-110">失効のキーが侵害され、新しい保護操作には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="bad0e-110">Revoked - the key is compromised and must not be used for new Protect operations.</span></span>

<span data-ttu-id="bad0e-111">受信したペイロードを解除するために、作成された、アクティブ、および有効期限が切れたキーをすべてに使用する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-111">Created, active, and expired keys may all be used to unprotect incoming payloads.</span></span> <span data-ttu-id="bad0e-112">既定では失効したキーが、ペイロードを解除するために使用できませんが、アプリケーション開発者は[この動作をオーバーライド](xref:security/data-protection/consumer-apis/dangerous-unprotect#data-protection-consumer-apis-dangerous-unprotect)必要な場合。</span><span class="sxs-lookup"><span data-stu-id="bad0e-112">Revoked keys by default may not be used to unprotect payloads, but the application developer can [override this behavior](xref:security/data-protection/consumer-apis/dangerous-unprotect#data-protection-consumer-apis-dangerous-unprotect) if necessary.</span></span>

>[!WARNING]
> <span data-ttu-id="bad0e-113">開発者は、(例: ファイル システムから対応するファイルを削除する) をキー リングからキーを削除したくなるかもしれません。</span><span class="sxs-lookup"><span data-stu-id="bad0e-113">The developer might be tempted to delete a key from the key ring (e.g., by deleting the corresponding file from the file system).</span></span> <span data-ttu-id="bad0e-114">その時点では、キーによって保護されているすべてのデータが完全に解読し、失効したキーであるような緊急のオーバーライドはありません。</span><span class="sxs-lookup"><span data-stu-id="bad0e-114">At that point, all data protected by the key is permanently undecipherable, and there's no emergency override like there's with revoked keys.</span></span> <span data-ttu-id="bad0e-115">、本当に破壊的な動作は、キーの削除と、その結果、データ保護システムを公開しませんファーストクラス API この操作を実行するためです。</span><span class="sxs-lookup"><span data-stu-id="bad0e-115">Deleting a key is truly destructive behavior, and consequently the data protection system exposes no first-class API for performing this operation.</span></span>

## <a name="default-key-selection"></a><span data-ttu-id="bad0e-116">既定のキーの選択</span><span class="sxs-lookup"><span data-stu-id="bad0e-116">Default key selection</span></span>

<span data-ttu-id="bad0e-117">データ保護システムでは、バックアップ リポジトリからキー リングを読み取り、ときに、"default"キーをキー リングから検出を試みます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-117">When the data protection system reads the key ring from the backing repository, it will attempt to locate a "default" key from the key ring.</span></span> <span data-ttu-id="bad0e-118">既定のキーは、新しい保護操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-118">The default key is used for new Protect operations.</span></span>

<span data-ttu-id="bad0e-119">一般的なヒューリスティックは、データ保護システムは、既定のキーとして、最新のアクティブ化日付のキーを選択します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-119">The general heuristic is that the data protection system chooses the key with the most recent activation date as the default key.</span></span> <span data-ttu-id="bad0e-120">(はサーバー間のクロックのずれを許可する一種の小さな) です。かどうか、アプリケーションが無効になっていない自動とキーの生成、キーが期限切れか失効してかどうかは、即時のライセンス認証ごとに新しいキーが生成されます、[キーの有効期限とローリング](xref:security/data-protection/implementation/key-management#data-protection-implementation-key-management-expiration)以下のポリシー。</span><span class="sxs-lookup"><span data-stu-id="bad0e-120">(There's a small fudge factor to allow for server-to-server clock skew.) If the key is expired or revoked, and if the application has not disabled automatic key generation, then a new key will be generated with immediate activation per the [key expiration and rolling](xref:security/data-protection/implementation/key-management#data-protection-implementation-key-management-expiration) policy below.</span></span>

<span data-ttu-id="bad0e-121">新しいキーの生成を新しいキーの前にアクティブ化されたすべてのキーの有効期限が暗黙の型として扱うことが別のキーへのフォールバックするのではなく、データ保護システム理由がすぐに新しいキーを生成します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-121">The reason the data protection system generates a new key immediately rather than falling back to a different key is that new key generation should be treated as an implicit expiration of all keys that were activated prior to the new key.</span></span> <span data-ttu-id="bad0e-122">一般的な考え方は、新しいキーが異なるアルゴリズムまたはより古いキーは、保存時の暗号化メカニズムで構成されている、システムは、フォールバックより現在の構成を優先する必要がありますです。</span><span class="sxs-lookup"><span data-stu-id="bad0e-122">The general idea is that new keys may have been configured with different algorithms or encryption-at-rest mechanisms than old keys, and the system should prefer the current configuration over falling back.</span></span>

<span data-ttu-id="bad0e-123">例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-123">There's an exception.</span></span> <span data-ttu-id="bad0e-124">アプリケーション開発者が[自動キーの生成を無効になっている](xref:security/data-protection/configuration/overview#disableautomatickeygeneration)、データ保護システムは、既定のキーとして何かを選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-124">If the application developer has [disabled automatic key generation](xref:security/data-protection/configuration/overview#disableautomatickeygeneration), then the data protection system must choose something as the default key.</span></span> <span data-ttu-id="bad0e-125">このフォールバックのシナリオでは、システムは、クラスター内の他のコンピューターに反映されるまでの時間があるキーに指定された基本設定、最新のライセンス認証日、失効していないキーを選択します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-125">In this fallback scenario, the system will choose the non-revoked key with the most recent activation date, with preference given to keys that have had time to propagate to other machines in the cluster.</span></span> <span data-ttu-id="bad0e-126">その結果、既定の有効期限が切れたキーを選択すること、フォールバック システムになります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-126">The fallback system may end up choosing an expired default key as a result.</span></span> <span data-ttu-id="bad0e-127">フォールバック システムは既定のキーと失効したキーを選択しないでくださいとキー リングが空か、すべてのキーが失効している場合は、システムが初期化時にエラーが発生します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-127">The fallback system will never choose a revoked key as the default key, and if the key ring is empty or every key has been revoked then the system will produce an error upon initialization.</span></span>

<a name="data-protection-implementation-key-management-expiration"></a>

## <a name="key-expiration-and-rolling"></a><span data-ttu-id="bad0e-128">キーの有効期限とロール</span><span class="sxs-lookup"><span data-stu-id="bad0e-128">Key expiration and rolling</span></span>

<span data-ttu-id="bad0e-129">キーが作成されるをアクティブ化する日の {0} 現在 + 2 日} と {現在 + 90 日間} の有効期限の日付が提供されて自動的に。</span><span class="sxs-lookup"><span data-stu-id="bad0e-129">When a key is created, it's automatically given an activation date of { now + 2 days } and an expiration date of { now + 90 days }.</span></span> <span data-ttu-id="bad0e-130">アクティブ化する前に 2 日間の遅延は、キーに反映されるまで、システム時刻を示します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-130">The 2-day delay before activation gives the key time to propagate through the system.</span></span> <span data-ttu-id="bad0e-131">つまり、強まることキー リングが反映されることになるはアクティブなときにする必要があるすべてのアプリケーションを使用して、その確率で、[次へ] の自動更新期間、キーを観察するその他のアプリケーション、バッキング ストアをポイントできます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-131">That is, it allows other applications pointing at the backing store to observe the key at their next auto-refresh period, thus maximizing the chances that when the key ring does become active it has propagated to all applications that might need to use it.</span></span>

<span data-ttu-id="bad0e-132">2 日以内の既定のキーを有効期限が切れると、既定のキーの期限切れ時にアクティブになるキーをキー リングを持っていない場合は、新しいキーをキー リングが自動的にデータ保護システムに保持します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-132">If the default key will expire within 2 days and if the key ring doesn't already have a key that will be active upon expiration of the default key, then the data protection system will automatically persist a new key to the key ring.</span></span> <span data-ttu-id="bad0e-133">この新しいキーについては、アクティブ化する日の既定のキーの有効期限日} と {現在 + 90 日間} の有効期限の日付。</span><span class="sxs-lookup"><span data-stu-id="bad0e-133">This new key has an activation date of { default key's expiration date } and an expiration date of { now + 90 days }.</span></span> <span data-ttu-id="bad0e-134">これにより、サービスの中断することなくが定期的にキーを自動的にロールバックするシステムです。</span><span class="sxs-lookup"><span data-stu-id="bad0e-134">This allows the system to automatically roll keys on a regular basis with no interruption of service.</span></span>

<span data-ttu-id="bad0e-135">ある可能性がありますの状況で即時のライセンス認証キーが作成される場所。</span><span class="sxs-lookup"><span data-stu-id="bad0e-135">There might be circumstances where a key will be created with immediate activation.</span></span> <span data-ttu-id="bad0e-136">1 つの例は、時間、アプリケーションが実行されていないし、キー リング内のすべてのキーが期限切れになります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-136">One example would be when the application hasn't run for a time and all keys in the key ring are expired.</span></span> <span data-ttu-id="bad0e-137">この場合、キーには、通常 2 日間のアクティブ化の待機時間なしの {0} には現在} のアクティブ化日付が与えられます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-137">When this happens, the key is given an activation date of { now } without the normal 2-day activation delay.</span></span>

<span data-ttu-id="bad0e-138">これが次の例のようには構成可能な既定キーの有効期間が 90 日間です。</span><span class="sxs-lookup"><span data-stu-id="bad0e-138">The default key lifetime is 90 days, though this is configurable as in the following example.</span></span>

```csharp
services.AddDataProtection()
       // use 14-day lifetime instead of 90-day lifetime
       .SetDefaultKeyLifetime(TimeSpan.FromDays(14));
```

<span data-ttu-id="bad0e-139">明示的に呼び出す場合、管理者は、システム全体の既定値を変更もできます`SetDefaultKeyLifetime`システム全体のポリシーよりも優先されます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-139">An administrator can also change the default system-wide, though an explicit call to `SetDefaultKeyLifetime` will override any system-wide policy.</span></span> <span data-ttu-id="bad0e-140">既定キーの有効期間は 7 日間より短くすることはできません。</span><span class="sxs-lookup"><span data-stu-id="bad0e-140">The default key lifetime cannot be shorter than 7 days.</span></span>

## <a name="automatic-key-ring-refresh"></a><span data-ttu-id="bad0e-141">キー リングを自動更新</span><span class="sxs-lookup"><span data-stu-id="bad0e-141">Automatic key ring refresh</span></span>

<span data-ttu-id="bad0e-142">データ保護システムでは、初期化時にキー リングを基になるリポジトリから読み取るし、メモリにキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="bad0e-142">When the data protection system initializes, it reads the key ring from the underlying repository and caches it in memory.</span></span> <span data-ttu-id="bad0e-143">このキャッシュは、保護と保護の解除の操作をバッキング ストアにアクセスせずに続行を許可します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-143">This cache allows Protect and Unprotect operations to proceed without hitting the backing store.</span></span> <span data-ttu-id="bad0e-144">システムでは、約 24 時間ごと、または現在の既定のキーの有効期限、先に達したときに、変更のバッキング ストアは自動的にチェックします。</span><span class="sxs-lookup"><span data-stu-id="bad0e-144">The system will automatically check the backing store for changes approximately every 24 hours or when the current default key expires, whichever comes first.</span></span>

>[!WARNING]
> <span data-ttu-id="bad0e-145">場合は、開発者が非常にまれには、キーの管理 Api を直接使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-145">Developers should very rarely (if ever) need to use the key management APIs directly.</span></span> <span data-ttu-id="bad0e-146">データ保護システムは前述のように、自動キー管理を実行します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-146">The data protection system will perform automatic key management as described above.</span></span>

<span data-ttu-id="bad0e-147">データ保護システム インターフェイスを公開する`IKeyManager`を使用して、検査し、キー リングを変更することができます。</span><span class="sxs-lookup"><span data-stu-id="bad0e-147">The data protection system exposes an interface `IKeyManager` that can be used to inspect and make changes to the key ring.</span></span> <span data-ttu-id="bad0e-148">インスタンスを提供する DI システム`IDataProtectionProvider`のインスタンスを指定できますも`IKeyManager`の使用量に対する。</span><span class="sxs-lookup"><span data-stu-id="bad0e-148">The DI system that provided the instance of `IDataProtectionProvider` can also provide an instance of `IKeyManager` for your consumption.</span></span> <span data-ttu-id="bad0e-149">また、プルすることができます、`IKeyManager`から直接、`IServiceProvider`次の例のようにします。</span><span class="sxs-lookup"><span data-stu-id="bad0e-149">Alternatively, you can pull the `IKeyManager` straight from the `IServiceProvider` as in the example below.</span></span>

<span data-ttu-id="bad0e-150">すべての操作 (新しいキーを明示的に作成または失効を実行する) のキー リングを変更するには、メモリ内キャッシュが無効になります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-150">Any operation which modifies the key ring (creating a new key explicitly or performing a revocation) will invalidate the in-memory cache.</span></span> <span data-ttu-id="bad0e-151">次回の呼び出し`Protect`または`Unprotect`により、データ保護システムをキー リングを読み込んで、キャッシュを再作成します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-151">The next call to `Protect` or `Unprotect` will cause the data protection system to reread the key ring and recreate the cache.</span></span>

<span data-ttu-id="bad0e-152">次の例では、使用方法を示します、`IKeyManager`インターフェイスを検査して取り消しの既存のキーと新しいキーを手動で生成するなど、キー リングを操作します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-152">The sample below demonstrates using the `IKeyManager` interface to inspect and manipulate the key ring, including revoking existing keys and generating a new key manually.</span></span>

[!code-csharp[](key-management/samples/key-management.cs)]

## <a name="key-storage"></a><span data-ttu-id="bad0e-153">キー ストレージ</span><span class="sxs-lookup"><span data-stu-id="bad0e-153">Key storage</span></span>

<span data-ttu-id="bad0e-154">データ保護システムでは、ヒューリスティックを適切なキー記憶域の場所と保存時の暗号化メカニズムを自動的に推定しようとすることがあります。</span><span class="sxs-lookup"><span data-stu-id="bad0e-154">The data protection system has a heuristic whereby it attempts to deduce an appropriate key storage location and encryption-at-rest mechanism automatically.</span></span> <span data-ttu-id="bad0e-155">キーの永続化メカニズムでは、アプリ開発者によって構成も。</span><span class="sxs-lookup"><span data-stu-id="bad0e-155">The key persistence mechanism is also configurable by the app developer.</span></span> <span data-ttu-id="bad0e-156">次のドキュメントでは、これらのメカニズムのボックスでの実装について説明します。</span><span class="sxs-lookup"><span data-stu-id="bad0e-156">The following documents discuss the in-box implementations of these mechanisms:</span></span>

* <xref:security/data-protection/implementation/key-storage-providers>
* <xref:security/data-protection/implementation/key-encryption-at-rest>
