---
title: サブキーの派生と ASP.NET Core での認証された暗号化
author: rick-anderson
description: サブキーの派生と認証暗号化を ASP.NET Core データ保護の実装の詳細について説明します。
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/01/2019
ms.locfileid: "57047249"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="9fbc9-103">サブキーの派生と ASP.NET Core での認証された暗号化</span><span class="sxs-lookup"><span data-stu-id="9fbc9-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="9fbc9-104">キー リング内のほとんどのキーは、何らかの形式のエントロピが含まれ、「CBC モードの暗号化 + HMAC の検証」というアルゴリズムの情報が含まれますか「GCM 暗号化 + 検証」です。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="9fbc9-105">このような場合は、埋め込みのエントロピをこのキーのマスター_キー生成情報 (または KM) と呼びます、実際の暗号化操作に使用されるキーを派生させるキー派生関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="9fbc9-106">キーは抽象クラスで、カスタム実装が次に示すように動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="9fbc9-107">キーは、独自の実装を提供する場合`IAuthenticatedEncryptor`組み込み工場のいずれかを使用してではなくこのセクションで説明されているメカニズムが適用されなくなった。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="9fbc9-108">追加の認証済みデータとサブキーの派生</span><span class="sxs-lookup"><span data-stu-id="9fbc9-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="9fbc9-109">`IAuthenticatedEncryptor`インターフェイスは、すべての認証された暗号化操作の主要なインターフェイスとして機能します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="9fbc9-110">その`Encrypt`メソッドは 2 つのバッファーを受け取ります。 プレーン テキストと additionalAuthenticatedData (AAD)。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="9fbc9-111">プレーン テキスト コンテンツのフローへの呼び出しをそのまま`IDataProtector.Protect`AAD は、システムによって生成され、3 つのコンポーネントで構成されていますが。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="9fbc9-112">32 ビット マジック ヘッダー 09 F0 C9 F0 このバージョンのデータの保護システムを識別します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="9fbc9-113">128 ビットのキー id。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="9fbc9-114">可変長文字列の形式を作成した目的のチェーンから、`IDataProtector`この操作を実行しています。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="9fbc9-115">AAD は 3 つの要素のタプルに対して一意であるためを KM から KM 自体ですべての暗号化の操作を使用する代わりに新しいキーを派生させるために使用できます。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="9fbc9-116">すべての呼び出しの`IAuthenticatedEncryptor.Encrypt`、次のキー派生のプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="9fbc9-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="9fbc9-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="9fbc9-118">ここでは、NIST SP800 108 の KDF カウンター モードで呼び出しています (を参照してください[108-NIST SP800](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)、1 秒あたりの 5.1) は次のパラメーター。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="9fbc9-119">キー派生キー (KDK) K_M を =</span><span class="sxs-lookup"><span data-stu-id="9fbc9-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="9fbc9-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="9fbc9-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="9fbc9-121">label = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="9fbc9-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="9fbc9-122">context = contextHeader || keyModifier</span><span class="sxs-lookup"><span data-stu-id="9fbc9-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="9fbc9-123">コンテキスト ヘッダーは可変長の基本的に拇印を K_E と K_H を派生しているアルゴリズムの役割を果たします。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="9fbc9-124">キーの修飾子は、呼び出しごとにランダムに生成される 128 ビット文字列`Encrypt`KE と KH がこの特定の認証の暗号化操作の一意の KDF への他のすべての入力が定数の場合でも確率を過負荷を確実に機能します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="9fbc9-125">CBC モードの暗号化 + HMAC 検証操作では、|K_E |対称ブロック暗号キーの長さと |K_H |HMAC ルーチンのダイジェストのサイズです。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="9fbc9-126">GCM の暗号化と検証の操作 |K_H |= 0。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="9fbc9-127">CBC モードの暗号化 + HMAC の検証</span><span class="sxs-lookup"><span data-stu-id="9fbc9-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="9fbc9-128">K_E が上記のメカニズムを使用して生成されるはランダムな初期化ベクトルを生成し、プレーン テキストを暗号化する対称ブロック暗号アルゴリズムを実行します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="9fbc9-129">初期化ベクター、暗号文は K_H MAC を生成するためにキーを使用して初期化 HMAC ルーチンを実行し、</span><span class="sxs-lookup"><span data-stu-id="9fbc9-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="9fbc9-130">このプロセスと戻り値は、以下でグラフィカルに表されます。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-130">This process and the return value is represented graphically below.</span></span>

![CBC モードの処理と戻り値](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="9fbc9-132">*出力: keyModifier を = | |iv | |E_cbc (K_E、iv、データ) | |HMAC (K_H、iv | |E_cbc (K_E、iv、データ))*</span><span class="sxs-lookup"><span data-stu-id="9fbc9-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="9fbc9-133">`IDataProtector.Protect`実装は[ヘッダー マジックとキーの id を付加](xref:security/data-protection/implementation/authenticated-encryption-details)を呼び出し元に返す前に出力します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="9fbc9-134">ヘッダーのマジックとキーの id は、暗黙的にするための一部[AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)、キー修飾子は、KDF への入力としてが取り込まれる、ため最終的なペイロードは返されるは 1 バイトずつが MAC で認証されると</span><span class="sxs-lookup"><span data-stu-id="9fbc9-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="9fbc9-135">Galois/カウンター モード暗号化と検証</span><span class="sxs-lookup"><span data-stu-id="9fbc9-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="9fbc9-136">K_E が上記のメカニズムを使用して生成されると、私たちランダム 96 ビットの nonce を生成し、プレーン テキストを暗号化して、128 ビット認証タグを生成する対称ブロック暗号アルゴリズムを実行します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM モードの処理と戻り値](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="9fbc9-138">*出力: keyModifier を = | |nonce | |E_gcm (K_E、nonce、データ) | |authTag*</span><span class="sxs-lookup"><span data-stu-id="9fbc9-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="9fbc9-139">GCM ネイティブ AAD の概念をサポートする場合でもいるまだ供給 AAD 元の KDF にのみ GCM に AAD パラメーターを空の文字列を渡すこと。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="9fbc9-140">この理由は、2 つあります。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-140">The reason for this is two-fold.</span></span> <span data-ttu-id="9fbc9-141">まず、[機敏性をサポートするために](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers)暗号化キーとして直接 K_M を使用することはありません。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="9fbc9-142">さらに、GCM では、その入力に一意性を非常に厳格な要件を課します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="9fbc9-143">GCM の暗号化ルーチンが 2 つが呼び出されたかより明確である確率を設定 (キー、nonce) 同じ入力データのペアが 2 を超えてはいけません ^32 です。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="9fbc9-144">2 以上を実行できない場合 K_E を修正しました ^2 への実行前に、32 の暗号化操作 ^-32 を制限します。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="9fbc9-145">操作の非常に大きい番号のように見えるかもしれませんが、高トラフィックの web サーバーは、これらのキーの通常の有効期間の範囲内の単なる日で 40億要求を通過できます。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="9fbc9-146">2 の準拠を維持する ^128 ビット キー修飾子と 96 ビットの nonce は、任意の特定 K_M の使用可能な操作の数を大幅に拡張を使用していく-32 確率の制限。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="9fbc9-147">わかりやすくするためのデザインの共有、CBC と GCM 操作の間の KDF コード パスと、AAD が既に、KDF でと見なされるためには、GCM ルーチンに転送する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9fbc9-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
